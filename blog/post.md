# DIY Binary Analysis
## Motivation
When we play in **CTF**s, we use _ghidra_, _IDA_, _binary ninja_ or other similar tools to look into binaries. These tools take the binary and magically give us the assembly instructions of the program. Usually these tools can also give us a _decompilation_ of the binary, which would be an attempt to recreate the source code of that program, the _inverse_ of the compilation process. Besides **CTF** competitions, antivirus software also need to pry into executable programs to catch possible malware, so the problem of analysing, and reversing a binary is an important, useful problem. <br>

In the world of software development, we tend to take things for granted, and at each level of abstraction we enjoy the fact that we do not need to know what goes on in the lower levels to make our code work. A web developer for example, works with javascript and relevant web frameworks, and doesn't really need to know what powers the javascript engine in the browsers running his code, or the intricate details of the plumbing happening in his web frameworks. Similarly, the developer of that web framework usually does not need to know about the underlying details of how the compilers he/she uses work, or how the CPU works and so on. But learning about the lower level details, and how the tools we use work, can be fun and rewarding. And what better way to learn about a tool than making one yourself? So in this post I am going to talk about what I learn't by making a simple tool for binary analysis. <br>

## What's in an ELF?
A short recap: when we write a simple hello world program in C, we have a _text_ file with the text being in some language (C) which the CPU doesn't really understand. To make this into something that the CPU can understand and execute, we resort to a compiler (like **gcc** or **clang**) and the compiler looks into our program (the **hello.c** file) and spews out an executable program (e.g. **a.out**) in a format which in linux, is called an **elf**. Actually there is more to it than that, an **elf** can hold _object files_ or _shared libraries_ too, but the point is, this file is no longer a human-readable text. So if you see the source of the program, you have a much easier time understanding the purpose of the code, but with the **elf** you get something not intended for a human to read! 

## Parsing the ELF
Parsing the elf header is a tenuous process of looking into the documentation and implementing it to the minute detail that it is specified. The elf contains information about the architecture of the machine, the endianness, and the layout of the other data in the file which includes the actual code of the program. The additional data is there so that the OS knows how to actually load the program in the memory and prepare it for execution. There are tools (like **readelf**) which display the information of an elf and can be used to verify our code. 
